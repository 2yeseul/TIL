# Coroutine

처음 코루틴이라는 개념을 접했을 때 굉장히 복잡했던 기억이 난다. 물론 지금도 코루틴이라는 개념이 절대 만만하지도 않고 여전히 어려운건 매한가지이지만,
알고보니 처음 접했던 개념보다는 훨씬 명료하여 정리해보고자 한다.

나 같은 경우 코루틴이라는 것을 코틀린을 배우기 전부터 알고 있었는데, 그냥 비동기적 프로그래밍을 지원하는 것 정도로만 알고 있었다.

그리고 현 회사에 입사하여 코루틴을 사용할 일이 생겨, `Kotlin In Action` 의 코루틴 챕터를 보고선 굉장히 당황했던 기억이 난다..
우선 Kotlin In Action 에서는 코루틴을 다음과 같이 정의하는데..
> 코루틴은 컴퓨터 프로그램 구성 요소 중 하나로 비선점형 멀티태스킹을 수행하는 일반화한 서브루틴이다.
> 코루틴은 실행을 일시 중단하고 재개할 수 있는 여러 진입 지점을 허용한다.

여전히 코린이지만 찐 코린이었던 당시에 이 문장을 보고 굉장히 당황했던 기억이 난다.. 비선점..? 그걸 일반화..? 

개인적으로 코루틴에 대한 설명은 코틀린 공식 사이트가 훨씬 친절하고 쉽게 되어있어, 입문자라면 [공식 reference](https://kotlinlang.org/docs/coroutines-guide.html)
를 참고하는 것을 추천한다. 코루틴과 동시성 프로그래밍의 전반적인 이해는 [이 블로그](https://wooooooak.github.io/kotlin/2019/08/25/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B0%9C%EB%85%90-%EC%9D%B5%ED%9E%88%EA%B8%B0/)
에 정리가 잘 되어있다.

코루틴을 이런 식으로 이해해본다면 조금 쉬울 것 같다. (내 기준..)

친구가 냉장고에서 아이스크림을 찾고 있었는데, 열린 냉장고에서 물을 꺼내야 한다고 가정하자.  

이를 코드로 표현해보면
``` kotlin 
friend.search(iceCream)
me.pick(water)
``` 
위가 일반적인 코드이지만, 문제점이 있다. 위 코드는 동기적이기 때문에, 친구가 아이스크림을 다 찾은 뒤에야 내가 물을 꺼낼 수 있다.

위에 정의된 코틀린의 특상인, `실행을 일시 중단` 할 수 있다는 점은 바로 이러한 문제를 해결해준다. 친구가 아이스크림을 아직 찾지 못했어도,
나는 물을 꺼낼 수 있도록 한다. 

``` kotlin

fun main(args: Array<String>) = runBlocking {
    launch {
        friend.search(iceCream)
    }
    me.pick(water)
}
```

`서브루틴` 은 쉽게 말해 함수이다. 
> 코루틴은 컴퓨터 프로그램 구성 요소 중 하나로 비선점형 멀티태스킹을 수행하는 일반화한 서브루틴이다.

이 말은 즉슨 다양한 함수들이 동시적으로 함수 내부의 일을 수행한다는 뜻이다. 그런데 이러한 멀티 태스킹이 실행되는 방식이 조금 흥미롭다. 
동시에 무언가를 수행하는 방법엔 다양한 것들이 있을 것이다. 

비선점형이라는 뜻은, 하나의 스레드를 서브루틴들이 독점하는 것이 아닌 필요에 따라 스레드를 사용한 뒤 반납한다는 개념으로 이해하면 쉬울 것 같다.

여러 개의 스레드를 통해 다양한 일을 병렬로 수행하는 방법도 있겠지만, 코루틴에서는 suspend 함수를 통해 중지 지점을 설정함으로써, 하나의 서브 루틴(함수)의 일이 끝나면 그 스레드를 다른 서브루틴에게 넘겨준다.

> 코루틴을 일시 중단하면 사용중인 스레드를 block 하는 것이 아니라, 다른 코루틴으로 하여금 본인들의 코드에 사용중이었던
스레드를 사용하도록 하는 것이다.

코루틴은 중지할 수 있는(suspendable) 연산의 인스턴스 이다. 쓰레드와 개념적으로 유사한데,
나머지 코드들과 동시에 작동하는 코드 블록을 실행해야 한다는 맥락에서 그러하다.

하지만 코루틴은 특정 스레드에 바인딩 되지 않는다.
코루틴은 한 스레드에서 실행을 중지하면, 다른 스레드에서 다시 시작할 수 있다.

코루틴을 경량 스레드 쯤으로 생각할 수도 있지만, 실제로는 코루틴과 스레드는 여러 중요한 차이점이 있다. 코루틴은 `협력하는 멀티태스킹` 을 기반으로 하기 때문이다.

코루틴은 단지 suspending function 들을 실행하고 중지 지점마다 context를 옮겨 다니는 것이다. 

## launch
`launch` 는 코루틴 빌더이다. 독립적으로 작동하는 나머지의 코드와 동시에 새로운 코루틴을 시작한다.

## delay
`delay`는 특정 시간동안 코루틴을 멈추는 특별한 suspend 함수이다.

> 코루틴을 일시 중단하면 사용중인 스레드를 block 하는 것이 아니라, 다른 코루틴으로 하여금 실행하고 본인들의 코드에 사용중이었던
스레드를 사용하도록 하는 것이다.

## runBlocking
`runBlocking` 역시 일반적인 메인 함수에서 코루틴이 아닌 것과 `runBlocking` 내의 코루틴을 연결하는 다리와 같은 코루틴 빌더이다.

`runBlocking` 의 의미는 이 코루틴을 실행하는 스레드가 요청한 시간동안 실행이 끝나기까지 block 되기 때문이다.

# Structured concurrency
코루틴은 구조화된 동시성의 원칙을 따르는데, 코루틴은 코루틴의 생명주기를 제한하는 특정한 `CoroutineScope` 내에서만 실행될 수 있다는 것을 뜻한다.

# Scope Builder

`coroutineScope` 빌더를 사용해서 스스로의 범위를 지정할 수도 있다. 코루틴의 범위를 생성하고, 하위 작업들이 전부 실행될 때 까지 끝나지 않는다.
`runBlocking`과 `coroutineScope` 빌더는 그들의 하위 작업들이 끝날 때 까지 기다린다는 점에서 비슷해 보인다. 주요한 차이점은 다음과 같다 :

`runBlocking`은 대기하는 동안 최근 사용된 thread를 block하지만, coroutineScope는 단순히 정지만 시키기 때문에 다른 곳에서도 해당 스레드를 사용할 수 있다.

이러한 차이점 때문에, `runBlocking`은 보통의 함수이고 `coroutineScope`은 suspend function 인 것이다.

# Suspending function
대부분의 코틀린 함수들은 `suspend` 가 붙어있는 suspending function 인데, 일반 함수와 큰 차이는 없다.

다만 suspend 함수들은 0개 이상의 `중지 지점`을 갖는다. 이 중지 지점은 보통 함수 내에 존재하는데, 함수의 실행을 중지하고 나중에 실행하는 선언문이 있다.

non-suspending 함수는 suspending 함수를 즉각적으로 부를 수 없는데, 그들이 suspension point들을 지원하지 않기 때문이다.
suspending 함수는 아무런 제약없이 non-suspending 함수를 호출할 수 있다. 물론 이러한 호출이 중지 지점을 만들어내는 것은 아니다.
