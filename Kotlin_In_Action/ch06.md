# 코틀린 타입 시스템

자바와 비교했을 때 코틀린의 타입 시스템은 코드의 가독성을 향상시키는 몇 가지 특성이 존재한다.
> 1. `nullable`
> 2. 읽기 전용 컬렉션

# 6.1 널 가능성
널 가능성은 NPE를 피할 수 있게 해주는 코틀린 타입시스템의 특성이다. 코틀린은 `null` 오류에 대하여 컴파일 시점에서 파악할 수 있도록 한다. 널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지하여, 런타임 시점에서 발생할 수 있는 예외를 줄인다.

## 6.1.1 널이 될 수 있는 타입
코틀린과 자바의 첫 번째이자 가장 중요한 차이는 __코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 것이다.__

즉 널이 될 수 있는 타입은, 프로그램 내의 프로퍼티나 변수에 대해 null을 허용하도록 한다. 변수가 널이 될 수 있다면, 그 변수에 대해 메서드를 호출했을 때 NPE가 발생할 수 있으므로 안전하지 않다. 따라서 코틀린은 그런 메서드를 호출할 수 없게 함으로써 오류를 방지한다. 

``` java 
int strLen(String str) {
    return str.length();
}
``` 
이 함수에 null을 넘기면 NPE가 발생하므로 안전하지 않다. str이 null인지 검사하는지는 함수를 사용하는 의도에 따라 달라진다.

``` kotlin
fun strLen(str: String) = s.length
```

다음과 같이 선언하면 null이 인자로 들어올 수 없는 경우이다.

`strLen(null)`과 같이 선언하면 컴파일 시 에러가 발생한다. 이러한

strLen 함수에서 str의 타입은 String인데, 이는 str이 항상 String 의 인스턴스여야 한다는 것을 의미한다. 컴파일러는 널이 될 수 있는 값을 strLen에게 넘기지 못한다.

이 함수가 널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 `물음표(?)` 를 명시해야한다.

``` kotlin
fun strLen(str: String?) = ...
```
어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티는 null을 참조를 저장할 수 있게 된다.


널이 될 수 있는 타입의 변수가 있다면, 그에 대해 수행할 수 있는 연산이 제한된다.

``` kotlin
fun strLenSafe(s: String?) = s.length()
```
와 같은 메서드는 컴파일 에러가 발생한다. 

다음과 같이 수정해야 올바른 코드이다.

``` kotlin
fun strLenSafe(s: String?) = if (s != null) s.length else 0
```

널 가능성을 다루기 위해 사용할 수 있는 도구가 if 검사 뿐이라면, 코드는 번잡해진다. 하지만 코틀린은 널이될 수 있는 값을 다룰 때 필요한 도구를 제공한다.

## 6.1.3 안전한 호출 연산자: ?.
`?.` 은 null검사와 메서드 호출을 한 번의 연산으로 수행한다.

예를들어, `s?.toUpperCase()` 는 훨씬 더 복잡한 `if(s != null) s.toUpperCase() else null` 과 같다.

``` kotlin
fun printAllCaps(s: String?) {
    val allCaps: String? = s?.toUpperCase();
    println(allCaps);
}
``` 