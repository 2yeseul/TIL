# Indexes

Index를 통해 MongoDB에서 효율적인 쿼리를 실행할 수 있다. 인덱스가 없이는, 컬렉션의 모든 document들이 해당 쿼리에 맞는지를 스캔한다. 이러한 경우, document들이 많다면 속도가 느려질 것이다.
따라서 인덱스를 생성함으로써, 더 적은 횟수의 조회로 원하는 데이터를 찾아낼 수 있다. 

# Index structure
인덱스들은 탐색하기 쉬운 형식으로, 컬렉션의 값 묶음의 작은 부분을 자정하는 데이터 구조로 이루어져 있다. 

인덱스들은 필드 값에 따라 정렬된 특정 필드의 값이나 값들의 집합이 저장되어있다. 
## B-Tree
B트리는 이진트리에서 발전되어, 모든 리프 노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리이다. 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있어서 DB에서 사용한다.

B트리는 이진트리와 다르게, 하나의 노드에 많은 수의 정보를 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B트리를 M차 B트리라고 하며, 다음과 같은 특징을 같는다.

- 노드는 최대 M개부터 M/2개 까지의 자식을 가질 수 있다.
- 노트에는 최대 M - 1 개 부터 (M / 2) - 1 개의 키가 포함될 수 있다.
- 노드의 키가 x개일 때, 자식의 수는 x + 1개이다.
- 최소 차수는 자식 수의 하한 값을 의미하며, 최소 차수가 t라면 M = 2t - 1를 만족한다.

[참고](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)


1부터 15까지의 정수가 있는 경우, 인덱스가 없을 땐 1부터 14까지를 쭉 조회하게 된다. 하지만 인덱스가 생성된 경우, 
![image](https://velopert.com/wp-content/uploads/2016/02/Untitled-7.png)
(출처 - https://velopert.com/560)
와 같은 B-Tree가 만들어지므로, 8 -> 12 -> 14 와 같이 조회가 가능하다. 

# 종류
## 기본 `_id` 인덱스 
MongoDb는 컬렉션을 생성할 때 `_id` 라는 unique index를 생성한다. _id는 두 documents가 같은 _id 값을 가지지 않도록한다. _id 필드를 따로 지정하지 않으면 mongodb 드라이버가 자동으로 생성한다. 

## Single 인덱스
단일 필드 값을 통해 정렬하고 싶은 경우 
## Compound 인덱스
쿼리에서 검색에 여러 키가 사용된 경우, 이 인덱스 타입으로 정의한다.

두 개 이상의 필드를 사용하는 경우, 특정 필드는 오름차순, 두번째 필드는 내림차순으로 정렬할 때 사용 
복합 인덱스는 순서가 중요한데, 첫 번째로 오는 인덱싱 조건은 '일치'이어야 하고, 범위를 지정한 키는 그 다음에 와야한다. 
## MultiKey 인덱스
필드타입이 배열인 필드에 인덱스를 적용할 때는 MultiKey 인덱스가 사용된다. 